\section{概率空间}

\frame{\sectionpage}

\begin{frame}{概率空间}
\begin{itemize}
	\item 试验与事件
	\item 古典型概率、几何型概率
	\item 概率空间
	\item 概率的性质
	\item 条件概率和乘法公式
	\item 事件的独立性
	\item 全概率公式和Bayes公式
	\item 概率空间的例子
	\item Borel-Cantelli引理
\end{itemize}
\end{frame}

\begin{frame}{Set Theory}
\alert{集合}是数学中最原始的概念.若要给它下定义,不得不引入新的概念来说明它.若要给这些新的概念下定义,又不得不引入另外的新的概念.这样就会导致无休止的讨论.因此,在直观的朴素集合论(naive set theory)中,集合被看成是无需下定义的基本概念.为了方便,我们愿意给集合概念一个直观的描述,但这不是给它下定义.(我们不打算介绍ZFC公理体系等公理化集合论,只介绍比较直观的朴素集合论,对于我们理解这门课,这已足够.)

\begin{itemize}
\item 集合论自19世纪80年代由G.Cantor创立以来,现在已经发展成独立的数学分支.
\item Russell悖论(Russell's paradox 或Russell's antinomy)的出现促使数学家产生了许多改进方案,就是把集合论公理化.

\item 最著名是ZF(Zermelo-Fraenkel)公理集合论体系,及其保守扩张GB(Gödel以及Bernays).
\end{itemize}
\end{frame}

\begin{frame}
\Large\alert{
在此,请同学们相信我们所提到的构造集合的方法都不会导致悖论.集合论中涉及数学基础的那些深层问题,也不会自己跳出来颠覆人们所发展的概率论方法.
}
\\ \hspace*{\fill} \\%空行
在正式开始学习概率论之前,让我们先复习一下集合论的一些简单知识.这些知识构成了概率论语言的基础.我们假定大家对于朴素的集合论已经具有了一定的了解,因此只将这些介绍蜻蜓点水式地简单回顾.
\end{frame}

\begin{frame}{Sets}
\begin{block}{\textbf{Definition}}
\begin{itemize}
\item \alert{集合}就是一些东西的总体.
\item 总体中的东西称为这个集合的\alert{元素}
\item 元素$\omega$是集合$A$的一个元素,称作元素$\omega$属于集合$A$,记作$\omega\in A$或者$A\ni\omega$.
\item 在一个数学问题中,常有这样一个集合$\Omega$,使得我们打算研究的所有对象都是这个特定集合的元素.这个集合$\Omega$常被称为(这个问题的)\alert{空间/全集}(universal set).
\end{itemize}	
\end{block}
\end{frame}

\begin{frame}
	众所周知,一个\alert{集合}(set)就是把一堆\alert{元素}(element)放在一起当作一个整体来看待.当$x$时$A$的元素的时候,我们也称$x$\alert{属于}(belong to)$A$,记为$x\in A$,否则称$x$不属于$A$,记为$x\notin A$.当两个集合相等当且仅当所含元素完全相同.于是证明两个集合$A=B$的标准办法就是去证明\begin{equation}
		x\in A\Longleftrightarrow x\in B.
	\end{equation}
	不含任何元素的集合称为\alert{空集}(empty set),记做$\emptyset$.
	\\ \hspace*{\fill} \\%空行
	但并不是说随便把一堆对象拿出来放在一起就可以构成一个集合,这会导致悖论.比如著名的\alert{Russell悖论}(Russell's paradox或Russell's antinomy)是说,如果定义$X$为“又所有不属于自己的集合构成的集合”,则从$X\in X$就能推出$X\notin X$,反过来从$X\notin X$也能推出$X\in X$,这是自相矛盾的.换言之有些构造集合的方法是安全的,有些则是不安去的,为了避免悖论的产生,无法用安全的方法实现的构造我们都不应当承认它是集合.下面介绍几种常规(即安全的)构造方法.
\end{frame}

\begin{frame}
	一种最常用的构造方法是从一个已知的集合中筛选出满足特定条件的元素,构成新的集合.已知$X$是一个集合,设$P(x)$是一个关于$x$的命题,则$X$中的元素使得命题$P(x)$成立的那些元素$x$就构成一个集合,记为\begin{equation}
		\{x\in X|P(x) \}.
	\end{equation}
	有些时候我们打算研究的对象都是某个特定集合$X$的元素,这时就把$X$称为\alert{全集}(universal set).所以Russell悖论和上述合法构造的差别就在于:悖论里构造的那个东西没有一个全集限定元素的选择范围.
	\\ \hspace*{\fill} \\%空行
	设$A,B$是两个集合,如果$x\in A$蕴含$x\in B$,则称$A$为$B$的\alert{子集}(subset)或者$A$\alert{包含于}(be included in)$B$,并称$B$\alert{包含}$A$,记作$A\subset B$或$B\supset A$.如果$A\subset B$,并且$A\neq B$,则称$A$为$B$的\alert{真子集}(proper subset).
\end{frame}


\begin{frame}
	$X$的全体子集也构成一个集合,称其为\alert{幂集}(power set),记为$2^X$.用这个记号是因为当$X$是恰好有$n$个元素的有限集时,$2^X$是恰好有$2^n$个元素的有限集.
	\\ \hspace*{\fill} \\%空行
	一个所有元素都是集合的集合称为\alert{集合族}(collection of sets).设$\mathcal{A}$是集合族,则可以定义$\mathcal{A}$的所有元素(都是集合)的\alert{交集}(intersection)$\cap\mathcal{A}$以及\alert{并集}(union)$\cup\mathcal{A}$如下:
	\begin{itemize}
		\item $x\in\cap\mathcal{A}$当且仅当$x$是每一个集合$A\in\mathcal{A}$的元素;
		\item $x\in\cup\mathcal{A}$当且仅当存在集合$A\in\mathcal{A}$,使得$x$是$A$的元素.
	\end{itemize}
	
\end{frame}

\begin{frame}
	这里有个小小的问题:如果$\mathcal{A}$不含任何元素,那么如何判断一个元素$x$是不是每个集合$A\in\mathcal{A}$的元素呢?为此我们规定$\cap\emptyset = \emptyset$.
	\\ \hspace*{\fill} \\%空行
	如果集合族$\mathcal{A}$只有两个元素$A$和$B$,则交集和并集就记为$A\cap B$和$A\cup B$.对于一般的集合族,人们也往往喜欢弄出一个指标集$\Lambda$,然后把集合族写成$\{A_{\lambda}\}_{\lambda\in\Lambda}$,并把交集和并集写成$\bigcap_{\lambda\in\Lambda}A_{\lambda}$和$\bigcup_{\lambda\in\Lambda}A_{\lambda}$的样子.请注意,指标集可以是任何集合,而不一定是自然数集或其子集,所以一般来说是不能对指标集应用数学归纳法的.
\end{frame}

\begin{frame}
	交和并的运算满足各自的交换律和结合律,也满足分配律,即
	\begin{itemize}
		\item \begin{equation}
		A\cup\left(\bigcap_{\lambda\in\Lambda}B_{\lambda} \right) = \bigcap_{\lambda\in\Lambda} \left(A\cup B_{\lambda} \right)
		\end{equation}
		\item \begin{equation}
		A\cap\left(\bigcup_{\lambda\in\Lambda}B_{\lambda} \right) = \bigcup_{\lambda\in\Lambda} \left(A\cap B_{\lambda} \right)
		\end{equation}
	\end{itemize}
	两个集合$A,B$的\alert{差集}(difference)定义为\begin{equation}
		A\backslash B = \{x\in A|x\notin B \},
	\end{equation}
	有时候,差集也记做$A-B$.
\end{frame}

\begin{frame}
	差集满足\alert{De Morgan定律}(De Morgan's law)
	\begin{itemize}
		\item \begin{equation}
			B\backslash\left(\bigcap_{\lambda\in\Lambda}A_{\lambda} \right) = \bigcup_{\lambda\in\Lambda}\left(B\backslash A_\lambda\right)
		\end{equation}
		\item \begin{equation}
			B\backslash\left(\bigcup_{\lambda\in\Lambda}A_{\lambda} \right) = \bigcap_{\lambda\in\Lambda}\left(B\backslash A_\lambda\right)
		\end{equation}
	\end{itemize}
	特别地,如果对于我们研究的问题有一个预先取定的全集$X$,则差集$X\backslash A$称为$A$对全集$X$的\alert{余集}或\alert{补集}(complement),记为$A^{c}$.注意,有些文献会习惯使用$\overline{A}$表示$A$的余集,但我们如果也使用这个符号,就会在后面讨论$A$的"闭包"时,会产生歧义,因而此处只使用$A^{c}$来表示$A$的余集.
\end{frame}
\begin{frame}
	\begin{block}{\textbf{Definition}}
		\begin{itemize}
			\item 一个\alert{映射}(map或mapping)$f$是两个集合$X$和$Y$的元素之间的一个对应关系,使得每个$X$的元素$x$都对应唯一一个$Y$的元素$f(x)$.
			\item 我们有时也把映射的定义简写为\begin{equation}
				f:X\rightarrow Y,x\mapsto f(x).
				\end{equation}
			\item 称$X$为$f$的\alert{定义域}(domain),$Y$为$f$的\alert{陪域}(codomain).
			\item 全体$X$到$Y$的映射也构成一个集合,记作$Y^X$.用这个记号是因为当$X$有$m$个元素,$Y$含$n$个元素时,$Y^X$恰好含$n^m$个元素.
		\end{itemize}	
	\end{block}
\end{frame}

\begin{frame}
	注意:幂集$2^\Omega$的元素可以和$\{0,1\}^\Omega$的元素建立起一一对应关系:每一子集$A\subset \Omega$对应的映射就定义为\begin{equation}
		\bm{1}_A:\Omega\rightarrow \{0,1\},\omega\mapsto\left\{
		\begin{aligned}
		1 &,~\omega\in A ;\\
		0  &,~\omega\in \Omega\backslash A.
		\end{aligned}
		\right.
	\end{equation}
		\\ \hspace*{\fill} \\%空行
	如果$y=f(x)$,则称$y$为$x$的\alert{像}(image),称$x$为$y$的一个\alert{原像}(preimage或inverse image).从定义可以看出,每个$x\in X$只能有一个像,但是每个$y\in Y$可以有很多原像,也可以没有原像.$y$的所有原像构成的集合记为$f^{-1}(y)$.如果$A$是$X$的子集,则称\begin{equation}
		f(A) = \{y\in Y|\text{存在} x\in A,\text{使得}f(x)=y\}
	\end{equation}
	为$A$的\alert{像集}(image).
\end{frame}

\begin{frame}
	如果$B$是$Y$的子集,则称\begin{equation}
		f^{-1}(B) = \{x\in X|f(x)\in B\}
	\end{equation}
	为$B$的\alert{原像集}(preimage或inverse image).
		\\ \hspace*{\fill} \\%空行
	不难验证,原像集满足下述简单的规律:
	\begin{itemize}
		\item \begin{equation}
			f^{-1}\left(\bigcap_{\lambda\in\Lambda}A_{\lambda} \right) = \bigcap_{\lambda\in\Lambda}f^{-1}\left(A_{\lambda}\right);
		\end{equation}
		\item \begin{equation}
			f^{-1}\left(\bigcup_{\lambda\in\Lambda}A_{\lambda} \right) = \bigcup_{\lambda\in\Lambda}f^{-1}\left(A_{\lambda}\right);
		\end{equation}
		\item \begin{equation}
			f^{-1}(A\backslash B) = f^{-1}(A) \backslash f^{-1}(B).
		\end{equation}
	\end{itemize}
\end{frame}

\begin{frame}
	但是,像集却完全可能不满足这些规律.
		\\ \hspace*{\fill} \\%空行	
	如果任取两个点$x_1,x_2\in X$,$x_1\neq x_2$蕴含$f(x_1)\neq f(x_2)$,则称$f$为\alert{单射} (injection).如果任取一个$Y$中的点$y$,$f^{-1}(y)\neq\emptyset$,则称$f$是\alert{满射} (surjection).如果$f$既是单射又是满射,则称$f$为\alert{双射} (bijection)或\alert{一一对应} (one-to-one correspondence).有时,也称双射为\alert{可逆映射} (invertible map),因为此时每一个$y\in Y$存在唯一原像,从而可以定义\alert{逆映射} (inverse)
	\begin{equation}
		f^{-1}:Y\to X,
	\end{equation}
	把每个$y\in Y$对应到它关于$f$的那个唯一原像.
\end{frame}

\begin{frame}
	任何集合上都可以定义\alert{恒同映射}(identity)\begin{equation}
		\mathrm{id}_X:X\to X,x\mapsto x.
	\end{equation}
	如果$A\subset X$,则可定义\alert{含入映射}(inclusion),也叫\alert{包含映射}\begin{equation}
		i_A:A\to X,x\mapsto x.
	\end{equation}
	若有两个映射$f:X\to Y$和$g:Y\to Z$,则可以定义\alert{复合映射}(composition)\begin{equation}
		g\circ f:X\to Z,x\mapsto g(f(x))
	\end{equation}
	不难验证,复合应黑色满足下述两个基本性质:
	\begin{itemize}
		\item 如果$g\circ f$是单射,则$f$是单射;
		\item 如果$g\circ f$是满射,则$g$是满射.
	\end{itemize}
\end{frame}

\begin{frame}
	若$X,Y$是两个集合,则全体有序对$(x,y)$(其中$x\in X,y\in Y$)也构成一个集合,称为$X$和$Y$的\alert{笛卡儿积}(Cartesian product)或\alert{直积}(direct product),记作$X\times Y$(英文Cartesian其实是将Descartes(笛卡儿)的名字形容词化之后的结果).也可以类似地定义有限多个集合的直积$X_1\times \cdots \times X_n$,即所有序列$(x_1,\cdots,x_n)$(其中每个$x_j\in X_j$)构成的集合,特别地,$n$个$X$的直积记为$X^n$,例如,实$n$维空间$\mathbb{R}^n = \mathbb{R}\times\cdots\times\mathbb{R}$.
\end{frame}


\begin{frame}
	Cantor最早发明集合论的时候说得很含糊,他说集合是“一些确定的、不同的东西的总体”.他开始想的其实只是实数集$\mathbb{R}$的子集.当然了,他更关心的是无穷子集.他首先发现,一个集合含有无穷多个元素的充分必要条件是它能和自己的一部分一一对应.然后他又提出了比较两个无穷集合所含元素的"个数"谁多谁少的方法.一般集合上这种相当于“个数”的概念称为\alert{基数}(cardinality)或\alert{势}(potency).如果集合$A$和$B$的元素能建立起一一对应,就称它们的基数相同,记为\begin{equation}
		\norm{A} = \norm{B}.
	\end{equation}
	如果$\norm{A}\neq\norm{B}$,但是$A$能和$B$的一部分一一对应,则称$A$的基数小于$B$的基数,记为\begin{equation}
		\norm{A} < \norm{B}.
	\end{equation}
\end{frame}

\begin{frame}
	Cantor很快便证明了$\norm{\mathbb{Q}} = \norm{\mathbb{N}}$,而$\norm{\mathbb{R}} > \norm{\mathbb{N}}$.然后他被一个问题难倒了:是否存在一个集合$A$,使得$\norm{\mathbb{N}}<\norm{A}<\norm{\mathbb{R}}$?Cantor猜想这样的集合不存在,这个猜想被称为连续统假设(因为$\mathbb{R}$的基数被称为连续统),但是他无法证明.
	\\ \hspace*{\fill} \\%空行
	给朴素的集合论想法带来更大打击的是悖论:不加限制地把“满足某种条件的对象”放在一起,有的时候构造出来的东西不能当作集合对待,也就是说,那些对于集合应该自然成立的结论到这里不一定成立,否则会导出自相矛盾的结果.
	\\ \hspace*{\fill} \\%空行
	比如Cantor就发现,把所有的对象放在一起后成一个大全集$\Omega$,$\Omega$就不能当作集合对待.因为否则的话,一方面任何集合的基数都不应该比$\Omega$的基数更大;而另一方面,如果考虑$\Omega$的幂集合$2^\Omega$,又可以像证明$\norm{\mathbb{R}} > \norm{\mathbb{N}}$那样证明$\norm{2^\Omega}>\norm{\Omega}$.这被称为\alert{Cantor悖论}(Cantor's paradox).
\end{frame}

\begin{frame}
	随后Russell(罗素)又发现了更简单直接的\alert{Russell悖论}(Russell's paradox或Russell's antinomy):把所有"不是自己的元素的集合"放在一起构成的那个东西也不能当作集合对待,因为否则的话记这个集合为$\Omega$,则$(\Omega\in \Omega)\Longleftrightarrow (\Omega\notin \Omega)$.
	\\ \hspace*{\fill} \\%空行
	想要避免悖论的发生,就必须要限制构造集合的方法,需要明确知道那些构造方法是安全的,只有那些符合安全规范的方法构造出来的对象才全是集合,才能放心大胆地应用关于集合的那些性质和命题.像前面零个悖论中的$\Omega$就都不算集合了.那然，那些最最基础的构造方法是不是安全是没法证明的,只能把每一条当做一个公理,这样得到的就是集合论的公理系统.历史的发展证明,只要对集合的构造方法加以限制,集合论就可能成为数学的可靠基础.
	
	
\end{frame}

\begin{frame}
最常用的集合论公理系统是ZF及其保守扩张GB(这里Z,F,G,B分别是其发明人Zermelo,Fraenkel,Gödel以及Bernays名字的第一个字母)
\\ \hspace*{\fill} \\%空行
ZF是\alert{Zermelo-Fraenkel集合论}（Zermelo-Fraenkel set theory）的简称，包括九条公理，每条公理是一个逻辑命题.注意ZF系统的所有命题中提到的对象都可以是集合，包括其中提到集合的元素时，这些元素课都可以是集合.仔细观察以下不难发现，这些公理中“某某集合存在”表达的其实都是“某某方式构造是对象算是集合”的意思.
\end{frame}

\begin{frame}
\alert{外延公理}（axiom of extensionality） 如果$x\in X$当且仅当$x\in Y$，则$X=Y$，即集合由其元素完全决定
\\ \hspace*{\fill} \\%空行
\alert{无序对公理}（axiom of pairing）$\forall x,y$，存在集合$\{x,y\}$（无序对）,使得$z\in \{x,y\}$当且仅当$z=x$或$z=y$.

Rmk:这里允许$x=y$，此时$\{x,y\}=\{x\}$.能区分$x,y$地位的有序对则定义为集合
\begin{equation}
(x,y) = \{\{x\},\{x,y\}\}.
\end{equation}
\\ \hspace*{\fill} \\%空行
\alert{并集公理}（axiom of union）$\forall \mathcal{A}$,存在集合$\cup\mathcal{A}$,使得$x\in\cup\mathcal{A}$当且仅当存在$A\in\mathcal{A}$满足$x\in A$.

结合无序对公理和并集公理可以归纳定义无序多元组如下:
\begin{equation}
\{x_1,\cdots,x_{n+1} \} = \{x_1,\cdots,x_{n} \} \cup \{x_{n+1}\}.
\end{equation}

\end{frame}

\begin{frame}
\alert{幂集公理}（axiom of power set）$\forall X$,存在集合$2^{X}$(幂集),使得$A\in 2^{X}$当且仅当 $A\subset X$.这里$A\subset X$是逻辑命题
\begin{equation}
\forall x\in A\Rightarrow x\in X
\end{equation}
(即$A$是$X$的子集)的简写.
\\ \hspace*{\fill} \\%空行
\alert{分离公理}（axiom schema of separation或axiom schema of specification） 任取集合$X$以及关于$x$的命题$P(x)$,存在集合$A$使得$x\in A$当且仅当$x\in X$并且$P(x)$成立.集合$A$通常记为$\{x\in X|P(x)\}$.

结合分离公理和并集公理,就可以把交集定义为
\begin{equation}
\cap \mathcal{A} = \{x\in\cup\mathcal{A}|\forall A\in\mathcal{A},x\in A \}.
\end{equation}
\end{frame}

\begin{frame}
注意到当$x\in X,y\in Y$时,前面定义的有序对$(x,y)$其实是一个由$X\cup Y$的子集构成的集合,这样的集合是$2^{X\cup Y}$的子集,也就是$2^{(2^{X\cup Y})}$的元素,因此利用分离公理,可以把直积(direct product)定义为
\begin{equation}
X\times Y = \{ z\in 2^{(2^{X\cup Y})}| \exists x\in X,y\in Y,\text{使得}z=(x,y) \}.
\end{equation}
直积也称作笛卡儿积(Cartesian product),其中英文Cartesian其实是将Descartes(笛卡儿)的名字形容词化之后的结果.

每个从$X$射到$Y$的映射$f:X\rightarrow Y$可以用它在$X\times Y$中的函数图像来刻画,因此也不需要添加新的公理,就可以把从$X$打到$Y$的映射定义为集合
\begin{equation}
Y^X = \{f\in 2^{X\times Y} | \forall x\in X,\text{存在唯一}\ y\in Y\ \text{使得}(x,y)\in f \}
\end{equation}
的元素.并且此时如果$(x,y)\in f$,则把$y$记为$f(x)$.
\end{frame}

\begin{frame}
\alert{空集公理}（axiom of empty set） 存在集合$\emptyset$(空集),使得$\forall x,x\notin \emptyset$.

由外延公理可以知道空集是唯一的.你也许会认为空集公理是多余的,因为有了分离公理可以随便取个集合,再取一个该集合中元素永远不满足的性质,然后就可以构造出空集来了,比如说$\emptyset=\{x\in A|x\notin A\}$.很多的书籍上也确实是这么写的,但是这实际上依赖于另外的一条其它公理中没有提到的假设:在这个世界上确实至少存在着那么一个集合$A$.缺少这个假设,形式逻辑的推理过程就没有了起点.当然,也有群体认为下面的一条公理"无穷公理"本身就包含了一定存在一个空集的意思.
\end{frame}

\begin{frame}
\alert{无穷公理}（axiom of infinity） 存在一个集合$\omega$(含有无穷多个元素的集合),使得$\emptyset\in\omega$,并且$x\in\omega$蕴含$x\cup\{x\}\in\omega$.

在集合论中,每个自然数$n$被归纳地定义成一个恰好有$n$个元素的特殊集合:
\begin{equation}
0=\emptyset,1=\{0\},\cdots,n+1=\{0,\cdots,n\} = n\cup\{n\}.
\end{equation}	

比较一下这个定义和上述无穷公理不难看出,自然数集$\mathbb{N}$就是满足无穷公理的最小集合.有趣的是关于自然数的加减乘除运算的各种基本性质都可以从这个定义以及ZF系统的其它公理推导出来.有了自然数之后当然也可以定义整数和有理数,并把数学分析中定义实数的方法(比如Cauchy序列或者Dedekind分割等等)也改写成符合ZF系统的形式.
\end{frame}

\begin{frame}
\alert{替换公理}(axiom schema of replacement)任取集合$X$以及关于$x,y$的逻辑命题$R(x,y)$,如果$R$满足$\forall x\in X$,存在唯一$y$使得该命题成立,则存在集合$Y$,使得$y\in Y$当且仅当存在一个$x\in X$使得$R(x,y)$成立.
\\ \hspace*{\fill} \\%空行
如果我们把$R(x,y)$理解成一个映射$f:x\mapsto y$,那么替换公理构造的$Y$其实就是$X$的象集$f(X)$.
\\ \hspace*{\fill} \\%空行
\alert{正则公理}(axiom of regularity)任取非空集合$X$,其中元素关于$\in$关系存在一个极小元素,即存在$x\in X$,使得$\forall y\in X,y\notin x$.
\\ \hspace*{\fill} \\%空行
注意:极小元素的选取并不一定唯一,也不一定是最小元素.有趣的是,任取两个自然数$m$和$n$,$m<n$当且仅当按照前述公理化定义把它们当作集合看待时$m\in n$.因此,这最后一条公理给出了\alert{数学归纳法}(mathematical induction)的一种新的理解:要想证明一系列命题$P_n$对任意$n\in\mathbb{N}$都成立,可以取$X=\{ n\in\mathbb{N}|\text{命题}P_n\text{不成立} \}$,则$X$一定含有一个极小元素$m$,从而任取自然数$i<m$,命题$P_i$成立.于是如果我们能从$P_0,\cdots,P_{m-1}$成立推导出命题$P_m$成立,就完成了证明.
\end{frame}


\begin{frame}
ZF是集合论的公理化体系中最简单可靠的一个.当然,简单可靠的代价就是应用上的局限性.有许多数学中的著名论断都需要在ZF之外再添加一条选择公理才能推推导出来.
\\ \hspace*{\fill} \\%空行
\alert{选择公理}(axiom of choice)任取一个由两两不相交的集合构成的集合族$\mathcal{A}$,存在一个集合$C$,它与$\mathcal{A}$的每个元素(元素是集合)都恰好交于一点.
\\ \hspace*{\fill} \\%空行
选择公理的一个简单推论是:任取一个集合族$\mathcal{A}$(不一定两两不交),存在一个映射$f:\mathcal{A}\mapsto\cup\mathcal{A}$,使得$\forall A\in\mathcal{A},f(A)\in A$.换言之,允许同时在集合族$\mathcal{A}$的每个元素(集合)里选择一个元素.


\end{frame}


\begin{frame}
选择公理是一个饱受争议的公理,数学家们一方面对于是否应该允许“同时”进行无穷多项的构造提出了强烈的质疑,另一方面又利用它证明了很多虚无缥缈、无法构造的东西存在.比如线性代数中任意线性空间中基的存在性,或者抽象代数中任意环的极大理想的存在性,或者实变函数(测度论)中不可测集的存在性,或者泛函分析中的Hahn-Banach定理,它们的证明过程中都直接或者间接地用到了选择公理,或者用到了在ZF中与选择公理等价的良序定理或Zorn引理.
\\ \hspace*{\fill} \\%空行
值得一提的是与不可测集的存在性相关的一个著名的结论,人们称之为\alert{Banach-Tarski悖论}(Banach-Tarski paradox).这个悖论大意是说,如果承认选择公理正确,则可以证明存在三维欧氏空间中的一族有限多个互不相交的子集,它们并起来是一个半径为$1$的实心球,但是把每个子集只进行一些旋转和平移,还可以在新的位置上保持互不相交地重新拼出两个半径为$1$的实心球.也就是将神话里的"分身术"找到了数学依据！这看上去显然是非常不符合常识的,这个结论也曾经一度被认为是选择公理不成立的直接证明,因此它才被称为"悖论"而不是"定理".
\end{frame}


\begin{frame}
当然,这个结论在逻辑上并没有任何矛盾,它只是和我们从多面体体积那里得来的常识相矛盾,有什么理由认为这些常识对于那些复杂得不可想象的子集也应该正确呢？今天的大部分数学家都倾向于站在选择公理一边,也就是说,当我们把一大堆没有体积的点胡乱堆在一起的时候,不应当假定这堆点的"体积"就一定符合积木方砖那种东西带给我们的几何常识.只不过在每一个需要用到选择公理的结论上,数学家们都会特意标注一下,省得将来反悔的时候不知道该丢弃些什么.我们也会这样处理.当然,对于本课的主要内容来说,ZF已经足够应用了.

\end{frame}

\begin{frame}
有趣的是,即使是用ZF加上选择公理构成所谓的ZFC,依然解决不了最初难道Cantor的连续统假设,或者说已经解决了,却不是Cantor想要的答案.Gödel在1940年证明了从ZFC出发不可能证明连续统假设是错误的,而Cohen则在1963年证明了从ZFC出发不可能证明连续统假设是正确的.
\end{frame}

\begin{frame}{Cantor-Bernstein 定理}
	
\end{frame}

\begin{frame}{集合系}
	集合系就是由集合组成的集合.在本课中可能用到的集合系有$\pi-\text{系}$、半环、半代数、环、代数、$\sigma-\text{环}$、$\sigma-\text{代数}$、单调系、$\lambda-\text{系}$等.这些集合系中最重要的是\alert{$\sigma-\text{代数}$},下面一一介绍这些集合系.
	\\ \hspace*{\fill} \\%空行
	\alert{$\pi-\text{系}$}:如果$X$上的非空集合系$\mathcal{P}$对交运算封闭,
	
	即\begin{equation}
		\forall A,B\in\mathcal{P} \implies AB\in\mathcal{P}.
	\end{equation} 
	则称$\mathcal{P}$为$\pi-\text{系}$.
	
	例:$\mathcal{P}_\mathbb{R} = \{(-\infty,a]|a\in\mathbb{R}  \}$对有限交的运算封闭,因而组成实数空间$\mathbb{R}$上的$\pi-\text{系}$.
\end{frame}

\begin{frame}
	\alert{半环}:满足下列条件的$\pi-\text{系}~\mathcal{S}$称为半环
\end{frame}

\begin{frame}{集合系之间的关系}
\Large
\begin{tabular}{ccccc}
	$\sigma-\text{代数}$ & $\Longleftrightarrow$ & $\pi-\text{系}$ & $+$ & $\lambda-\text{系}$ \\
	~ & ~ & ~ & ~ & $\Downarrow$ \\
	~  & $\Longleftrightarrow$ & 代数 & $+$ & 单调系 \\
\end{tabular}
\\ \hspace*{\fill} \\%空行
\hspace*{\fill} \\%空行
\begin{tabular}{ccccccc}
	$\sigma-\text{代数}$ & $\Longrightarrow$ & 代数 & $\Longrightarrow$ & 半代数 & ~ & ~ \\
	$\Downarrow$ & ~ & $\Downarrow$ & ~ & $\Downarrow$ & ~ & ~ \\
	$\sigma-\text{环}$ & $\Longrightarrow$ & 环 & $\Longrightarrow$ & 半环 & $\Longrightarrow$ & $\pi-\text{系}$
\end{tabular}
\end{frame}

\begin{frame}{测度论中的典型方法}
	在测度论和概率论中,为了证明一个关于可测函数的命题,常常分解为如下几个比较容易的步骤进行：
	\begin{itemize}
		\item (1)证明该命题对最简单的函数——\alert{示性函数}成立.
		\item (2)证明该命题对非负简单函数——\alert{示性函数的线性组合}成立.
		\item (3)证明该命题对非负可测函数——\alert{非降的非负简单函数列的极限}成立.
		\item (4)证明该命题对一般的可测函数——两个非负可测函数,即它的\alert{正部和负部之差}成立.
	\end{itemize}
	按上述步骤证明命题的方法叫做测度论中的\alert{典型方法}.典型方法符合人们的认识过程,是一种具有普遍意义、行之有效的方法,必须熟练掌握.
\end{frame}

